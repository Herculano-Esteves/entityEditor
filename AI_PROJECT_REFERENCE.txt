
AI_PROJECT_REFERENCE.txt

PROJECT: Entity Editor
VERSION: Deep Technical Reference 2.0 (Comprehensive)
DATE: 2026-02-05

================================================================================
1. INTRODUCTION & PHILOSOPHY
================================================================================

This project is a specialized 2D Entity Editor for a game engine. It solves the specific problem of composing "Complex Entities" — game objects made of multiple sprites (Body Parts) and collision boxes (Hitboxes) — outside of the game engine itself.

Design Philosophy:
1.  **Strict Separation of Data & Logic**: The editor produces data (`.entdef` files). It defines *what* an entity is, not *how* it behaves.
2.  **Pixel-Perfect Precision**: Used for 2D pixel-art games. Coordinates, sizes, and grids are integer-based where possible.
3.  **Project-Awareness**: The editor is not just a file viewer; it is a project management tool. It understands the folder structure of the game it is editing via `.gameproj` files.
4.  **Indirect Asset Linking**: Assets (textures) are referenced by Immutable IDs, not fragile file paths. This allows assets to move without breaking entities.

================================================================================
2. PROJECT STRUCTURE & MODULES
================================================================================

Root Directory: `src/`

--------------------------------------------------------------------------------
A. LAUNCHER & ENTRY
--------------------------------------------------------------------------------
- `launcher.py`: The entry point.
    - **Responsibilities**:
        1. Checks `session_manager` for the last opened project.
        2. If found, loads it and starts `MainWindow`.
        3. If not, prompts user to select a `.gameproj`.
    - **Key Dependencies**: `sys`, `QApplication`, `MainWindow`.

--------------------------------------------------------------------------------
B. COMMON (`src/common/`) - Shared Utilities
--------------------------------------------------------------------------------
- `game_project.py` -> `class GameProject`
    - Represents the configuration of the game being edited.
    - **Attributes**:
        - `root_dir`: Absolute path to the project folder.
        - `assets_root`: Relative path to assets (default: "assets").
        - `entities_path`: Relative path to entity storage.
    - **Methods**:
        - `load(filepath)`: Parses `.gameproj` (INI-style key=value).
        - `resolve_path(rel_path)`: Converts project-relative path to absolute system path.
    
- `session_manager.py` -> `class SessionManager`
    - Manages `last_session.json` in the user's app data or local folder.
    - **Purpose**: "Remember where I left off".
    
- `texture_registry.py` -> `class TextureRegistry`
    - **Critical Component**: The database of Texture IDs.
    - **Structure**: simple dictionary `{"HERO_IDLE": "textures/hero/idle.png"}`.
    - **Persistence**: 
        - Primary: `texture_registry.bin` (Binary dict).
        - Debug: `texture_registry.json`.
    - **API**: `get(id)`, `add_texture(key, path)`, `save()`.

--------------------------------------------------------------------------------
C. CORE (`src/tools/entity_editor/core/`) - Application Logic
--------------------------------------------------------------------------------
- `state/editor_state.py` -> `class EditorState`
    - **The Brain**. Singleton-patterned access to the application state.
    - **Holds**:
        - `current_entity`: The `Entity` object being edited.
        - `project`: The active `GameProject`.
        - `selection`: `Selection` object (tracks selected BodyParts/Hitboxes).
        - `grid_settings`: Visibility and size of the grid.
    - **Signals**: Emits `entity_changed`, `selection_changed`, `grid_changed`.
    
- `command.py` -> `class Command`, `class AddBodyPartCommand`, etc.
    - **Undo/Redo System**: Implements the Command Pattern.
    - Every action (Move, Rename, Add, Delete) is a class.
    - `do()`: Executes logic.
    - `undo()`: Reverses logic.
    
- `services/history_service.py` -> `class HistoryService`
    - Manages the Undo Stack.
    - Pushes commands, executes them, and notifies listeners.

- `naming_utils.py`
    - **Rule**: No two BodyParts in an Entity can typically share a name (enforced for easier runtime lookup).
    - **Function**: `get_unique_name(base, existing_names)` -> adds `_copy1`, `_copy2` suffix.

--------------------------------------------------------------------------------
D. DATA (`src/tools/entity_editor/data/`) - The Model
--------------------------------------------------------------------------------
- `entity_data.py` - **The Schema**
    - `class Entity`:
        - `name`: str
        - `pivot`: Vec2 (Global pivot point)
        - `body_parts`: List[BodyPart]
    - `class BodyPart`:
        - `name`: str
        - `texture_id`: str (The Registry Key)
        - `pos`, `size`: Vec2
        - `uv_rect`: Rect (0-1 normalized)
        - `z_index`: int
        - `transform`: Rotation, Scale, Flip
    - `class Hitbox`:
        - `rect`: Integer-based rectangle (x, y, w, h).
        - `type`: CollisionType enum.

- `file_io.py` - **Binary Packer**
    - Low-level `struct.pack` / `struct.unpack` logic.
    - Defines the `.entdef` file format spec.

--------------------------------------------------------------------------------
E. RENDERING (`src/tools/entity_editor/rendering/`)
--------------------------------------------------------------------------------
- `texture_manager.py` -> `class TextureManager`
    - **Bridge**: Connects IDs -> Registry -> Files -> QPixmap.
    - **Caching**: Keeps loaded textures in memory to avoid IO on every frame.
    - **Fallback**: If `get_texture("MISSING_ID")` is called, it generates a procedural 64x64 Magenta/Black checkerboard texture.
    - **Path Resolution**: ALWAYS resolves relative to `project.assets_root`.

--------------------------------------------------------------------------------
F. UI - VIEWPORT (`src/tools/entity_editor/ui/viewport/`)
--------------------------------------------------------------------------------
- `viewport_widget.py` (`QWidget`)
    - The raw canvas. Receives `mousePress`, `mouseMove`, `wheelEvent`.
    - Forwards events to the `ViewportController` or active `Tool`.
    
- `viewport_renderer.py`
    - **Pure Painter**. Accepts an `Entity` + `QPainter` and draws.
    - **Drafting Order**:
        1. Grid background.
        2. Origin Crosshair.
        3. BodyParts (Sorted by Z-Index).
        4. Selection Highlight (Outline).
        5. Hitboxes (Semi-transparent overlay).
        6. Pivot Points.

- `viewport_controller.py`
    - Coordinates Zoom, Pan, and Tool switching.

- `tools/select_tool.py`
    - Handles logic for: Clicking to select, Dragging to move, and Resizing via gizmo handles.
    - **Complex Logic**: Direct Manipulation (during drag) vs Command Commit (on release).

--------------------------------------------------------------------------------
G. UI - PANELS (`src/tools/entity_editor/ui/panels/`)
--------------------------------------------------------------------------------
- `bodyparts_panel.py`
    - **List View**: Shows hierarchy of parts. Drag-drop for Z-ordering.
    - **Properties**: Name, Position (SpinBoxes), Size.
    - **Texture Selector**: A `QComboBox` populated from the `TextureRegistry`. Selecting an ID updates the part.

- `main_window.py`
    - Orchestrator.
    - Initializes `EditorState`, `TextureRegistry`.
    - Sets up Docks, Menu Bar, Tool Bar.
    - Handles File Open/Save dialogs (with intelligent path defaulting).

--------------------------------------------------------------------------------
3. DATA FLOW EXAMPLE: "User Changes a Texture"
--------------------------------------------------------------------------------
1. **User Action**: Selects "HERO_RUN" from the ComboBox in `BodyPartsPanel`.
2. **UI Handler**: `_on_texture_changed` is triggered.
3. **Command Creation**: A `ModifyBodyPartCommand` is instantiated with the new `texture_id`.
4. **Execution**: Command is pushed to `HistoryService`.
    - `do()`: Updates `body_part.texture_id = "HERO_RUN"`.
    - Emits `entity_changed` signal.
5. **Updates**:
    - `BodyPartsPanel` hears signal -> Refreshes other fields if needed.
    - `ViewportWidget` hears signal -> Triggers `repaint()`.
6. **Rendering**:
    - `ViewportRenderer` asks `TextureManager.get_texture("HERO_RUN")`.
    - `TextureManager` checks Registry -> Finds "textures/hero_run.png".
    - Loads image -> Returns QPixmap.
    - Renderer draws the sprite.

--------------------------------------------------------------------------------
4. FILE FORMAT SPECIFICATION (.entdef)
--------------------------------------------------------------------------------
The binary format is custom and sequential. All strings are Pascal-strings (Int Length + Bytes).

[HEADER]
- Magic (4 bytes): 'ENTD'
- Version (2 bytes): 1

[ENTITY BLOCK]
- Name (String)
- Pivot X, Y (Float, Float)
- BodyPart Count (Int)

[BODY PART BLOCK] (Repeated Count times)
- Name (String)
- TextureID (String)
- Pos X, Y (Float, Float)
- Size W, H (Float, Float)
- UV X, Y, W, H (Floats, 0-1)
- Z-Index (Int)
- Flags (Byte: Visible, FlipX, FlipY)
- Rotation (Float)
- Hitbox Count (Int)

[HITBOX BLOCK] (Repeated Hitbox Count times)
- Name (String)
- Type (Int Enum)
- Rect X, Y, W, H (Int)

--------------------------------------------------------------------------------
5. HOW TO EXTEND THIS PROJECT
--------------------------------------------------------------------------------

Scenario: Adding "Tint Color" to BodyParts.

1.  **Modify Data**: 
    - Go to `src/tools/entity_editor/data/entity_data.py`.
    - In `BodyPart` dataclass, add `tint: Tuple[int, int, int] = (255, 255, 255)`.
    - Update `BodyPart.to_dict()` and `from_dict()` to handle this field.

2.  **Update Serialization**:
    - Go to `src/tools/entity_editor/data/file_io.py`.
    - Update `write_body_part` to `pack` 3 unsigned bytes (RGB).
    - Update `read_body_part` to `unpack` them. **WARNING**: This breaks file compatibility (bump version!).

3.  **Update Logic**:
    - Go to `src/tools/entity_editor/core/command.py`.
    - Ensure `ModifyBodyPartCommand` handles the 'tint' attribute generic updating (it usually does if it uses `setattr`).

4.  **Update UI**:
    - Go to `src/tools/entity_editor/ui/panels/bodyparts_panel.py`.
    - Add a "Color Picker" button.
    - Connect button -> Color Dialog -> `Command` creation.

5.  **Update Rendering**:
    - Go to `src/tools/entity_editor/ui/viewport/viewport_renderer.py`.
    - Inside `_draw_body_part_texture`:
        - Retrieve the pixmap.
        - Create a composition/overlay using `QPainter.CompositionMode_Multiply` with the tint color.
        - Draw the tinted result.

================================================================================
END OF REFERENCE
================================================================================
