# ENTITY EDITOR - AI TECHNICAL REFERENCE
# Last Updated: 2026-01-22
# Python Entity Editor for Game Engine - Complete Technical Documentation

## PROJECT OVERVIEW
Desktop application for creating and editing game entity definitions with body parts, hitboxes, textures, and UV mapping.
Framework: PySide6 (Qt6 for Python)
Python Version: 3.x
File Format: Binary .entdef + JSON export capability

## DIRECTORY STRUCTURE
```
entityEditor/
â”œâ”€â”€ main.py                          # Application entry point
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ signal_hub.py           # Central event dispatcher (Qt signals)
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ entity_data.py          # Core data models (Vec2, Hitbox, BodyPart, Entity)
â”‚   â”‚   â””â”€â”€ file_io.py              # Binary/JSON serialization
â”‚   â”œâ”€â”€ rendering/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ texture_manager.py      # Texture loading and caching
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main_window.py          # Main application window
â”‚   â”‚   â”œâ”€â”€ dialogs/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ uv_editor_dialog.py # Modal UV editing dialog
â”‚   â”‚   â”œâ”€â”€ panels/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ bodyparts_panel.py  # Body parts list and properties
â”‚   â”‚   â”‚   â””â”€â”€ hitbox_panel.py     # Hitbox list and properties
â”‚   â”‚   â””â”€â”€ widgets/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ viewport_widget.py  # Main 2D viewport with rendering
â”‚   â”‚       â””â”€â”€ uv_editor_widget.py # UV texture preview widget
â””â”€â”€ examples/                        # Sample entity files
```

## CORE DATA MODELS (src/data/entity_data.py)

### Vec2 (@dataclass)
- Fields: x (float), y (float)
- Methods: to_dict(), from_dict(data)
- Usage: Positions, sizes throughout application

### UVRect (@dataclass)
- Fields: x, y, width, height (all float, normalized 0.0-1.0)
- Methods: to_dict(), from_dict(data), get_pixel_coords(tex_width, tex_height)
- Purpose: Define texture region for body parts

### Hitbox (@dataclass)
- Fields:
  * name (str)
  * position (Vec2) - relative to parent body part
  * size (Vec2)
  * hitbox_type (str) - "collision", "damage", or "trigger"
  * enabled (bool) - visibility toggle
- Methods: to_dict(), from_dict(data)
- Parent: Attached to BodyPart.hitboxes list

### BodyPart (@dataclass)
- Fields:
  * name (str)
  * position (Vec2) - world position
  * size (Vec2) - pixel dimensions
  * texture_path (str)
  * uv_rect (UVRect)
  * flip_x (bool) - horizontal flip
  * flip_y (bool) - vertical flip
  * hitboxes (List[Hitbox])
  * uv_tile_id (Optional[str])
  * pixel_scale (int) - sprite scale multiplier (1-16)
  * rotation (float) - degrees
  * z_order (int) - draw order (higher = front)
  * visible (bool) - visibility toggle
- Methods: to_dict(), from_dict(data)

### Entity (@dataclass)
- Fields:
  * name (str)
  * entity_id (str) - UUID
  * pivot (Vec2) - entity center point
  * body_parts (List[BodyPart])
  * entity_hitboxes (List[Hitbox])
  * version (str)
  * tags (List[str])
  * metadata (Dict[str, Any])
- Methods: to_dict(), from_dict(data), get_body_part(name), add_body_part(bp), remove_body_part(bp), get_sorted_body_parts()

## SIGNAL HUB ARCHITECTURE (src/core/signal_hub.py)

### Purpose
Central event dispatcher using Qt signals for decoupled communication between UI components.
Singleton pattern via get_signal_hub() function.

### Signals Available
```python
# Entity signals
entity_loaded = Signal(object)
entity_modified = Signal()
entity_saved = Signal(str)

# Body part signals
bodypart_selected = Signal(object)
bodypart_added = Signal(object)
bodypart_removed = Signal(object)
bodypart_modified = Signal(object)
bodypart_reordered = Signal()

# Hitbox signals
hitbox_selected = Signal(object)
hitbox_added = Signal(object)
hitbox_removed = Signal(object)
hitbox_modified = Signal(object)
hitbox_edit_mode_changed = Signal(bool)

# Viewport signals
viewport_selection_changed = Signal(object)
viewport_transform_changed = Signal()
snap_value_changed = Signal(float)

# UV/Texture signals
texture_loaded = Signal(str)
uv_modified = Signal(object)
```

### Notify Methods Pattern
Each signal has corresponding notify_* method:
- notify_bodypart_selected(bodypart)
- notify_bodypart_modified(bodypart)
- etc.

Most modify methods automatically emit entity_modified signal.

## UI ARCHITECTURE

### MainWindow (src/ui/main_window.py)
- QMainWindow with menu bar, toolbar, status bar
- Layout: Central viewport widget + docked panels
- Toolbar Features:
  * Grid snap dropdown (Off, 1px, 2px, 4px, 8px, 16px, 32px, Custom)
  * Zoom controls
- File Menu: New, Open, Save, Save As, Export as JSON, Recent Files
- Signal Connections: Connects to signal hub for entity events

### ViewportWidget (src/ui/widgets/viewport_widget.py)
**Purpose:** Main 2D rendering area for entity preview and interaction

**State Variables:**
- _entity: Current Entity object
- _selected_bodypart: Currently selected body part
- _selected_hitbox: Currently selected hitbox
- _zoom: Viewport zoom level (0.1-10.0)
- _view_center: QPointF for pan offset
- _snap_value: Grid snap value in pixels (0 = off)
- _hitbox_edit_mode: Boolean for hitbox editing mode
- _dragging_hitbox: Currently dragged/resized hitbox
- _resize_edge: String identifier for resize edge ('tl', 'tr', 'bl', 'br', 'left', 'right', 'top', 'bottom')

**Key Methods:**
- paintEvent(): Custom QPainter rendering
- _draw_entity(painter): Renders all body parts with transformations
- _draw_bodypart(painter, bp): Renders single body part with pixel_scale, rotation, flipping
- _draw_hitbox(painter, hitbox, offset): Renders hitbox with type-based coloring
- _get_bodypart_at(world_pos): Hit detection for body parts
- _get_hitbox_at(world_pos): Hit detection for hitboxes (scoped to selected body part)
- _get_hitbox_edge(hitbox, parent_bp, world_pos): Detects edge/corner for resize
- _screen_to_world(screen_pos): Coordinate transformation
- _world_to_screen(world_pos): Inverse coordinate transformation
- _update_cursor_for_hover(screen_pos): Dynamic cursor changes for resize indicators

**Mouse Interaction:**
- Left click: Select body part/hitbox
- Left drag: Move body part (always pixel-snapped) or move/resize hitbox in edit mode
- Middle/Right drag: Pan viewport
- Scroll wheel: Zoom

**Rendering Features:**
- Pixel-perfect rendering (Qt.FastTransformation disabled for crisp pixel art)
- Body part transformations: pixel_scale, rotation, flip_x, flip_y
- Hitbox visibility: Only shows hitboxes from selected body part (or all if none selected)
- Selection highlight: Yellow outline for selected hitbox in edit mode
- Resize handles: 4 corner circles on selected hitbox when edit mode active

### BodyPartsPanel (src/ui/panels/bodyparts_panel.py)
**Purpose:** List and edit body parts

**UI Components:**
- _bodyparts_list: QListWidget with custom item widgets
- Custom Item Widget Structure:
  * Eye button (ğŸ‘ visible / âš« hidden)
  * QLabel with body part name
- Property Editors (enabled when body part selected):
  * Name (QLineEdit) - editingFinished signal
  * Position X/Y (QSpinBox) - integer pixels
  * Size Width/Height (QSpinBox) - integer pixels
  * Pixel Scale (QSpinBox 1-16x)
  * Z-Order (QSpinBox -100 to 100)
  * Rotation (QSpinBox -360Â° to 360Â°)
  * Flip X/Y (QCheckBox)
  * Texture Path (QLineEdit + Browse button)
  * Edit UV Map button (opens UVEditorDialog)

**Buttons:**
- Add: Creates new body part (default z_order=0)
- Remove: Deletes selected body part
- Rename: Focuses name field
- Duplicate: Deep copy with incremented name, offset position

**Important Methods:**
- _refresh_list(): Rebuilds list with custom widgets and eye icons
- _toggle_visibility(bodypart): Toggles visible field
- _on_name_changed(): Updates label widget only (no list refresh to prevent deselection)
- _on_property_changed(): Updates selected body part from UI inputs

### HitboxPanel (src/ui/panels/hitbox_panel.py)
**Purpose:** List and edit hitboxes for selected body part

**UI Components:**
- Info label: Shows selected body part context
- _hitbox_list: QListWidget with custom item widgets
- Custom Item Widget Structure:
  * Eye button (ğŸ‘ enabled / âš« disabled)
  * Colored type indicator (ğŸ”´ collision, ğŸŸ¡ damage, ğŸŸ¢ trigger)
  * QLabel with hitbox name
- Edit Hitboxes checkbox: Toggles viewport hitbox edit mode (disabled when no body part selected)
- Property Editors:
  * Name (QLineEdit) - editingFinished signal
  * Type (QComboBox: collision, damage, trigger)
  * Position X/Y (QDoubleSpinBox) - relative to parent body part
  * Size Width/Height (QDoubleSpinBox)

**Buttons:**
- Add: Creates new hitbox with parent's rendered size as default
- Duplicate: Deep copy with incremented name, offset position
- Remove: Deletes selected hitbox

**Important Behaviors:**
- Only shows hitboxes from currently selected body part
- Edit mode checkbox disabled when no body part selected
- Auto-disables edit mode when body part deselected
- Default hitbox size = parent body part size Ã— pixel_scale

### UVEditorDialog (src/ui/dialogs/uv_editor_dialog.py)
**Purpose:** Modal dialog for precise UV editing

**UI Layout:**
- Left: UVEditorWidget (visual texture + draggable UV rectangle)
- Right: Dual coordinate inputs
  * UV Coordinates (QDoubleSpinBox 0.0-1.0 normalized)
  * Pixel Coordinates (QSpinBox absolute pixels)
  * Two-way real-time synchronization
- Texture browse button
- OK/Cancel buttons

**Features:**
- Auto-calculates and updates body part size to match UV region pixels
- Runs auto-fix on dialog open to sync outdated sizes
- Visual resize handles with smart scaling/hiding
- Pixel-perfect snapping enforced

### UVEditorWidget (src/ui/widgets/uv_editor_widget.py)
**Implementation:** Direct QPainter rendering (not QGraphicsView)

**Rendering:**
- Background texture with Qt.FastTransformation
- UV rectangle overlay with resize handles
- Handle scaling inversely with zoom
- Handles hidden if UV rect < 20x20 pixels

**Interaction:**
- Drag rectangle body to move
- Drag handles to resize
- Pixel snapping enforced on all operations

## FILE I/O (src/data/file_io.py)

### EntitySerializer
**Static Methods:**
- save_binary(entity, filepath): Saves to .entdef binary format with struct packing
- load_binary(filepath): Loads from .entdef binary format
- save_json_debug(entity, filepath): Exports human-readable JSON
- load_json(filepath): Loads from JSON format

**Binary Format Specification:**
- Header: Magic bytes, version number
- Body: Struct-packed binary data
- Ensures compact file size and fast loading

## KEY FEATURES IMPLEMENTATION DETAILS

### Pixel-Perfect Coordinate System
- ALL position/size inputs use QSpinBox (integers only)
- Viewport dragging always rounds to whole pixels: `round(value)`
- Grid snapping applied on top: `round(value / snap) * snap`
- No QDoubleSpinBox for positions/sizes to enforce pixel precision

### Grid Snapping System
**Location:** MainWindow toolbar
**Values:** Off, 1, 2, 4, 8, 16, 32, Custom
**Behavior:** Always active when value > 0 (no Ctrl key required)
**Implementation:**
```python
def _snap_to_grid(value: float) -> float:
    if snap_value <= 0:
        return value
    return round(value / snap_value) * snap_value
```

### Pixel Scale Multiplier
**Field:** BodyPart.pixel_scale (int, default 1, range 1-16)
**Purpose:** Scale sprite rendering without changing UV region
**Auto-sizing Logic:**
1. When texture assigned or UV modified:
   - Calculate pixel dimensions of UV region
   - Set body part size = UV pixels (1:1 mapping)
2. Rendering applies pixel_scale as multiplier
3. Rendered size = size Ã— pixel_scale

### UV Flipping
**Fields:** BodyPart.flip_x, BodyPart.flip_y (bool)
**Implementation:** QTransform applied during paintEvent
```python
if bp.flip_x or bp.flip_y:
    transform = QTransform()
    if bp.flip_x:
        transform.scale(-1, 1)
    if bp.flip_y:
        transform.scale(1, -1)
    sub_pixmap = sub_pixmap.transformed(transform)
```

### Body Part Rotation
**Field:** BodyPart.rotation (float, degrees, range -360 to 360)
**Implementation:**
```python
painter.save()
center_x = bp.position.x + render_width / 2
center_y = bp.position.y + render_height / 2
painter.translate(center_x, center_y)
painter.rotate(bp.rotation)
painter.translate(-center_x, -center_y)
# draw sprite
painter.restore()
```

### Visibility Toggle System
**Fields:** BodyPart.visible, Hitbox.enabled (both bool)
**UI:** Eye button icons (ğŸ‘ = visible/enabled, âš« = hidden/disabled)
**Implementation:** Custom QListWidget items with embedded QPushButton
**Update Pattern:**
```python
def _toggle_visibility(item):
    item.visible = not item.visible
    signal_hub.notify_modified(item)
    # Update only the button icon, not entire list
    widget.findChild(QPushButton).setText("ğŸ‘" if item.visible else "âš«")
```

### Hitbox Editing Mode
**Trigger:** Checkbox in HitboxPanel
**Signal:** hitbox_edit_mode_changed(bool)
**Viewport Behavior Changes:**
- Hit detection prioritizes hitboxes over body parts
- Shows resize handles on selected hitbox
- Edge/corner detection for resize operations
- Dynamic cursor changes (â†” â†• â†–â†˜ â†—â†™ âœ¥)

**Resize Implementation:**
```python
# Edge detection with grab_distance = 8 / zoom
# Corner priority: tl, tr, bl, br
# Edge fallback: left, right, top, bottom
# Resize applies to both position and size for left/top edges
# Grid snapping applies to all resize operations
```

### Body Part Scoped Hitbox Visibility
**Rule:** Only hitboxes from selected body part are visible/interactive
**Implementation:**
- _get_hitbox_at() filters by _selected_bodypart
- _draw_hitbox() only draws if bp == _selected_bodypart or _selected_bodypart is None

### Duplicate Functionality
**Smart Naming:**
```python
if name ends with digit:
    increment that digit (e.g., "Torso2" â†’ "Torso3")
else:
    append "2" (e.g., "Head" â†’ "Head2")
```
**Position Offset:** +5 pixels X and Y
**Selection:** Auto-select the new duplicate

### Name Editing Without Deselection
**Problem:** List refresh on every keystroke caused deselection
**Solution:**
- Name field uses `editingFinished` signal (not `textChanged`)
- On name change completion: Find QLabel widget in custom item, update text directly
- No list rebuild â†’ no deselection
```python
current_item = list_widget.currentItem()
widget = list_widget.itemWidget(current_item)
label = widget.findChild(QLabel)
label.setText(new_name)
```

## RENDERING PIPELINE

### Viewport Paint Event Flow
1. Clear background (dark gray)
2. Setup world transform (center + zoom + pan)
3. Draw grid if enabled
4. Draw entity:
   a. Sort body parts by z_order
   b. For each visible body part:
      - Load texture from TextureManager
      - Extract UV sub-region as QPixmap
      - Apply flipping if needed
      - Save painter state
      - Apply rotation transform if needed
      - Draw scaled pixmap (size Ã— pixel_scale)
      - Restore painter state
      - Draw selection highlight if selected
      - Draw hitboxes (only if this bp is selected or none selected)
5. Draw UI overlay (zoom level, coordinates)

### Texture Rendering Settings
**Critical:** All texture rendering uses Qt.FastTransformation or disables SmoothPixmapTransform
**Affected Components:**
- ViewportWidget.paintEvent()
- UVEditorWidget rendering
- TextureBackgroundItem (if using QGraphicsView)

**Reason:** Prevents blurry pixel art, maintains crisp edges at all zoom levels

## ADVANCED INTERACTION PATTERNS

### Cursor Feedback System
**Location:** ViewportWidget._update_cursor_for_hover()
**Triggers:** mouseMoveEvent when not actively dragging
**Cursor Types:**
- Qt.SizeFDiagCursor: â†–â†˜ (tl, br corners)
- Qt.SizeBDiagCursor: â†—â†™ (tr, bl corners)
- Qt.SizeHorCursor: â†” (left, right edges)
- Qt.SizeVerCursor: â†• (top, bottom edges)
- Qt.SizeAllCursor: âœ¥ (over hitbox body)
- Qt.ArrowCursor: default

### Hitbox Resize Edge Detection
**Grab Distance:** 8 pixels in world space (adjusts with zoom)
**Priority Order:**
1. Check all 4 corners first (higher priority)
2. Then check 4 edges
3. Return None if not near any edge/corner

**Corner Identifiers:** 'tl', 'tr', 'bl', 'br'
**Edge Identifiers:** 'left', 'right', 'top', 'bottom'

### Coordinate Transformation Math
```python
# Screen to World
center = QPointF(width/2, height/2)
offset_x = screen_pos.x() - center.x()
offset_y = screen_pos.y() - center.y()
world_x = view_center.x() + offset_x / zoom
world_y = view_center.y() + offset_y / zoom

# World to Screen (inverse)
offset_x = (world_pos.x() - view_center.x()) * zoom
offset_y = (world_pos.y() - view_center.y()) * zoom
screen_x = center.x() + offset_x
screen_y = center.y() + offset_y
```

## COMMON PATTERNS AND CONVENTIONS

### Signal Handler Naming
- External events: `_on_external_selection(item)`
- UI events: `_on_button_clicked()`, `_on_value_changed()`
- Signal emission: Via signal_hub.notify_*() methods

### Property Update Flow
1. User modifies UI widget
2. Signal fires (valueChanged, editingFinished, etc.)
3. Handler updates data model
4. Handler calls signal_hub.notify_*_modified()
5. Signal hub emits modification signals
6. Other panels receive signals and update if needed
7. Viewport receives signal and calls update() for repaint

### List Widget Custom Items Pattern
```python
item = QListWidgetItem()
item.setData(Qt.UserRole, data_object)
widget = QWidget()
layout = QHBoxLayout(widget)
# Add eye button, labels, etc to layout
item.setSizeHint(widget.sizeHint())
list_widget.addItem(item)
list_widget.setItemWidget(item, widget)
```

### Blocking Signals Pattern
```python
widget.blockSignals(True)
widget.setValue(new_value)  # Won't trigger valueChanged
widget.blockSignals(False)
```
Used in _update_properties() to prevent feedback loops

## DEPENDENCIES
- PySide6: Qt6 GUI framework
- Python 3.x standard library: dataclasses, struct, pathlib, uuid, json, copy, re

## FILE FORMAT VERSION
Current: 1.0
Extensible via Entity.metadata dictionary
Backwards compatibility via default values in from_dict() methods

## KNOWN DESIGN DECISIONS

1. **Modal UV Editor:** Chosen over dockable for focused workflow, less UI clutter
2. **Direct QPainter:** Used instead of QGraphicsView for viewport/UV editor for reliable, predictable rendering
3. **Integer Coordinates:** All positions/sizes enforce integers via QSpinBox for pixel-perfect precision
4. **Always-On Grid Snap:** No Ctrl key required, simplified user interaction
5. **Body Part Scoped Hitboxes:** Prevents accidental interaction with other parts' hitboxes
6. **Separate Name Handler:** editingFinished instead of textChanged prevents deselection
7. **Auto-Size on UV Change:** Maintains 1:1 pixel mapping, makes pixel_scale behave as true multiplier
8. **Custom List Items:** Allows eye icons and rich formatting without QItemDelegate complexity

## TESTING WORKFLOW
1. Launch: `python main.py`
2. Create entity: File â†’ New
3. Add body part: Body Parts Panel â†’ Add
4. Assign texture: Properties â†’ Browse
5. Edit UV: Properties â†’ Edit UV Map
6. Add hitbox: Hitbox Panel â†’ Add
7. Enable edit mode: Hitbox Panel â†’ Edit Hitboxes checkbox
8. Save: File â†’ Save As â†’ .entdef
9. Export: File â†’ Export as JSON

## EXTENSION POINTS
- Entity.metadata: Custom fields without changing core data model
- BodyPart.uv_tile_id: Future UV tile library system
- Signal hub: Add new signals for new features
- Panels: Create new QWidget panels and dock in MainWindow
- File formats: Add new serializers in EntitySerializer
