
AI_PROJECT_REFERENCE.txt

PROJECT: Entity Editor
VERSION: Technical Reference 1.0
DATE: 2026-01-25

--------------------------------------------------------------------------------
1. PROJECT OVERVIEW
--------------------------------------------------------------------------------

What the tool is:
The Entity Editor is a standalone desktop application built with Python and PySide6 (Qt). It allows game developers to define 2D game "Entities" composed of multiple visual "Body Parts" (sprites) and logical "Hitboxes".

What problem it solves:
It decouples the definition of complex 2D compound objects from the game engine. Instead of hardcoding relative positions, uvs, and collision boxes in code or using a generic engine editor, this tool provides a specialized environment for pixel-perfect assembly of character rigs, props, or interactive objects.

Development Stage:
The project is in an active "Alpha" state.
- Core systems (Data, Rendering, UI, IO) are implemented and functional.
- Recent feature pushes have added usability constraints (Z-order, naming uniqueness, isolation).
- Architectural transitions are in progress (e.g., centralizing state management).
- Refactoring is ongoing to ensure maintainability over performance.

--------------------------------------------------------------------------------
2. HIGH-LEVEL ARCHITECTURE
--------------------------------------------------------------------------------

Folder Structure:
src/
  core/         -> Application logic, state management, command pattern (Undo/Redo), signaling.
  data/         -> Pure data models (dataclasses) and serialization logic.
  rendering/    -> Resources management (TextureManager).
  ui/           -> All Qt-based interface code.
    dialogs/    -> Modal windows (UV Editor).
    panels/     -> Dockable property editors (BodyParts, Hitboxes).
    viewport/   -> The 2D canvas (Widget, Renderer, Tools, Controller).
    widgets/    -> Reusable custom widgets.

Major Systems:

1. State Management (src.core.state)
   - 'EditorState' is the singleton-like source of truth.
   - It holds the 'Entity', manages 'Selection', and 'HistoryService'.
   - It acts as the bridge between logic and UI, partially replacing the legacy 'SignalHub'.

2. Signal System (src.core.signal_hub)
   - A central event bus used to decouple components.
   - UI components emit signals here; other components listen.
   - NOTE: This is currently being superseded by direct signals in 'EditorState', resulting in a mix of patterns.

3. Undo/Redo (src.core.command)
   - Implements the Command Pattern.
   - All model mutations are encapsulated in Command classes (e.g., AddBodyPartCommand).
   - 'HistoryService' manages the undo stack.

4. Rendering (src.ui.viewport.viewport_renderer)
   - Uses QPainter for immediate mode rendering.
   - Decoupled from the generic QWidget logic.

Data Flow:
User Action (UI) -> Tool/Panel Logic -> Creates Command -> HistoryService Executes Command -> Model Updated -> Signal Emitted -> UI Refreshes.

--------------------------------------------------------------------------------
3. DATA MODELS
--------------------------------------------------------------------------------

Defined in: src.data.entity_data

1. Entity
   - Root container.
   - Properties: Name, Pivot (Vec2), ID (UUID).
   - Children: List[BodyPart], List[Hitbox] (Entity-level hitboxes).

2. BodyPart
   - A visual component.
   - Properties: Position (Vec2), Size (Vec2), Texture Path, UVRect, Z-Order (int), Visibility (bool).
   - Transformation: Rotation (float), Pixel Scale (int), Flip X/Y (bool).
   - Children: List[Hitbox] (attached to this part).

3. Hitbox
   - A logic/collision rectangle.
   - Properties: Name, Position (relative), Size, Type (collision/damage/trigger), Enabled (bool).
   - CONSTRAINTS: Position and Size are STRICT INTEGERS for pixel-perfect logic.

4. UVRect
   - Normalized coordinates (0.0 - 1.0) defining the texture sub-region.

5. Vec2
   - Float-based vector class for positions and sizes.

--------------------------------------------------------------------------------
4. UI ARCHITECTURE
--------------------------------------------------------------------------------

Main Window (src.ui.main_window):
- Uses QMainWindow.
- Central Widget: ViewportWidget.
- Dock Widgets: BodyPartsPanel (Right), HitboxPanel (Right/Bottom).

Viewport System (src.ui.viewport):
- ViewportWidget: Handles Qt events (paint, mouse, key).
- ViewportRenderer: Pure logic class that paints the Entity state onto a QPainter.
- SelectTool: Handles mouse interaction logic (hit testing, dragging).
- ViewportController: Connects the Widget to the State/SignalHub.

Interactions:
- Mouse: Left Click to Select, Drag to Move/Resize.
- Tools: Currently only "Select Tool" is fully implemented.
- Selection behavior mimics rendering order (WYSIWYG).

--------------------------------------------------------------------------------
5. COORDINATE SYSTEMS
--------------------------------------------------------------------------------

1. World Space (Entity Space)
   - Origin (0,0) is the Entity's Pivot point.
   - Y-Axis increases downwards (Screen coordinates).
   - Units: "Virtual Pixels".

2. Body Part Space
   - Position is relative to World Space Origin.
   - Rotation is around the Body Part's geometric center (calculated at render time).

3. Hitbox Space
   - Position (x,y) is relative to the Parent Body Part's top-left corner (position).
   - Units: strict integer pixels.

4. Texture Space (UVs)
   - Normalized (0.0 to 1.0).
   - (0,0) is Top-Left of the texture image.

--------------------------------------------------------------------------------
6. FILE I/O
--------------------------------------------------------------------------------

Handled in: src.data.file_io

Current Format: Binary (.entdef)
- Uses Python 'struct' for packing data.
- Header string identifier.
- Sequential packing of Entity props, then BodyParts count, then BodyParts, etc.

Export: JSON
- Supports debug/interchange export to human-readable JSON.

Saving/Loading Pipeline:
- State.entity -> to_dict() -> JSON/Binary Packer -> Disk.
- Disk -> Unpack -> from_dict() -> State.entity.

Limitations:
- No version migration logic implemented yet. Changing data structure breaks old files.
- Texture paths are stored as strings; relative path logic is basic.

--------------------------------------------------------------------------------
7. CURRENT CAPABILITIES
--------------------------------------------------------------------------------

Functional:
- Adding/Removing/Duplicating Body Parts and Hitboxes.
- Transforming Body Parts (Move, Resize, Rotate, Scale, Flip).
- Editing UVs via visual dialog.
- Texture loading (BMP, PNG, JPG).
- Z-Order sorting and reordering via Drag-and-Drop in list.
- "Selection on Top" mode for easier editing of layered parts.
- Isolation Mode ("Solo") for Body Parts.
- Hitbox visibility toggling.
- Undo/Redo for all structural and property changes.
- Naming unique enforcement (automatic _copyN suffixing).

Partially Functional:
- Entity-level Hitboxes (defined in data, but UI primarily focuses on BodyPart hitboxes).
- Zoom/Pan (Basic implementation exists).

--------------------------------------------------------------------------------
8. KNOWN ISSUES & MISTAKES
--------------------------------------------------------------------------------

Architectural Flaws:
- SignalHub vs EditorState: There is split reliability on where signals come from. Some parts listen to Command execution, others to SignalHub. Ideally, EditorState should be the sole emitter.
- Direct Model Mutation: In some interactive tools (like SelectTool dragging), the model (BodyPart) is mutated directly, then a signal is emitted. This bypasses the Command pattern during the drag (for performance), which is acceptable, but "End Drag" must commit a Command to history properly.

Bugs/Inconsistencies:
- List Scroll Reset: Fixed recently, but relies on manual save/restore in UI code, which is brittle.
- Duplication Offset: Was removed based on user feedback, duplicates now stack directly on top, which can be confusing visually without the list selection change.

Technical Debt:
- The `SelectTool` iterates body parts in reverse render order to find click targets. This logic duplicates the Renderer's sort logic. If Renderer changes sorting (e.g., Layer support), SelectTool must be manually updated.
- `ViewportController` is somewhat anemic; logic leaks into `ViewportWidget` and `SelectTool`.

--------------------------------------------------------------------------------
9. DESIGN PHILOSOPHY
--------------------------------------------------------------------------------

1. Pixel Precision Over Smoothness
   - Integers are enforced for positions and sizes.
   - Snapping logic is aggressive.
   - Anti-aliasing is explicitly disabled for textures to support pixel art workflows.

2. WYSIWYG Selection
   - If you see it on top, you select it.
   - "Selection on Top" mode breaks physical Z-order to aid editing, but interaction logic adapts to match this visual lie.

3. Strict Naming
   - No two parts can share a name.
   - The system aggressively renames to avoid conflicts/ambiguity, which aids later export/runtime logic.

4. Modularity
   - Panels are self-contained.
   - Renderer is stateless (fed data).
   - Tools are state machines.

--------------------------------------------------------------------------------
10. EXTENSION GUIDELINES
--------------------------------------------------------------------------------

How to add a new property (e.g., Opacity):
1. DATA: Add `opacity: float = 1.0` to `BodyPart` dataclass in `src.data.entity_data`. Update `to_dict`/`from_dict`.
2. COMMAND: Update `ModifyBodyPartCommand` in `src.core.command` to handle the new key (generic state application usually handles this via setattr, but verify).
3. UI: Add QSpinBox/Slider to `BodyPartsPanel`.
4. LOGIC: Connect UI signal to a handler that constructs a `ModifyBodyPartCommand`.
5. RENDER: Update `ViewportRenderer` to apply opacity to the QPainter/QPixmap.

Where NOT to add logic:
- Do not put business logic in `ViewportWidget`. It should only route events.
- Do not modify data models directly from UI Panels without going through `EditorState` or `Commands` (unless it's a transient drag operation).

--------------------------------------------------------------------------------
11. DEVELOPMENT ROADMAP (Inferred)
--------------------------------------------------------------------------------

Immediate priorities:
1. Complete the migration from `SignalHub` to `EditorState` signals to remove the hybrid architecture.
2. Refactor `SelectTool` hit detection to use a shared "RenderSorter" helper to eliminate logic duplication with `ViewportRenderer`.
3. Implement Entity-level Hitbox UI management (currently obscure).

Future Features:
- Animation Timeline: The structure (Parts + Transforms) is ready for keyframing.
- Texture Atlas Support: `UVTile` data classes exist but are underutilized.
- Skeletal Binding: Parent/Child relationships between BodyParts (currently flat list).
